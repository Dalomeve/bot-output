# Top 3 Implementable Skill Specifications

**Date:** 2026-03-01  
**Source:** Ranked candidates from 2026-03-01-ranked.md

---

## Skill 1: session-recovery-guard

### Problem Statement
After any tool error (e.g., web_fetch aborted, failed API call), all subsequent tool calls in the same session fail with "Tool not found" errors even though the gateway is healthy. The session becomes completely unusable until manually reset, causing workflow interruption and potential data loss.

**Reference:** Issue #30723 - "Session I/O tools lost in Telegram DM after tool errors"

### Trigger Conditions
- Tool call returns error response (any tool: browser, exec, web_fetch, etc.)
- Subsequent tool call in same session fails with "Tool not found"
- Gateway health check shows gateway is running normally
- Session age < 24 hours (not natural expiration)

### Inputs
- Current session key/identifier
- Last tool call error details
- Gateway health status endpoint
- Session message history (last 10 messages)

### Step-by-Step Workflow

1. **Detect Tool Failure Pattern**
   - Monitor tool call responses for errors
   - On first tool error, set internal flag: tool_error_detected = true
   - Log error type, timestamp, and tool name

2. **Verify Session Corruption**
   - On next tool call attempt, check if error = "Tool not found"
   - If yes, confirm gateway health via /status or health endpoint
   - If gateway healthy but tools unavailable, mark session as corrupted

3. **Auto-Recovery Sequence**
   - Pause current task execution
   - Send system message: "Detected session tool corruption. Initiating recovery..."
   - Trigger session reset via internal API (preserve message history)
   - Wait for reset confirmation (max 10 seconds)

4. **Restore Context**
   - Reload last 5 messages from session history
   - Re-initialize tool registry
   - Verify tool availability with test call (health check tool)

5. **Resume Task**
   - Notify user: "Session recovered. Resuming [task name]..."
   - Retry the failed tool call from step 1
   - Continue normal execution

6. **Log Recovery Event**
   - Write to memory/YYYY-MM-DD.md:
     - Timestamp
     - Original error type
     - Recovery success/failure
     - Time to recovery

### Verification Checklist (Objective Pass/Fail)

- [ ] **PASS:** Tool error detected within 1 second of occurrence
- [ ] **PASS:** Session corruption confirmed (gateway healthy, tools unavailable)
- [ ] **PASS:** Recovery initiated within 3 seconds of corruption detection
- [ ] **PASS:** All core tools (read, write, exec, browser) available after reset
- [ ] **PASS:** Original task resumes without user re-prompting
- [ ] **PASS:** Recovery event logged to memory file
- [ ] **FAIL:** If recovery fails after 2 attempts, escalate to user with exact error

### Fallback Path

**If auto-recovery fails:**
1. Notify user immediately: "Session recovery failed. Manual reset required."
2. Provide exact reset command: /reset or gateway restart instruction
3. Preserve session history to memory file before reset
4. Offer to resume task in new session with context restored

**If corruption recurs >3 times in 24 hours:**
1. Flag as systemic issue
2. Create GitHub issue with error logs
3. Disable auto-recovery, require manual intervention
4. Notify user of pattern and recommended workaround

### Privacy/Safety Guardrails

- **No data loss:** Session message history preserved before reset
- **User notification:** Always inform user before and after recovery action
- **Bounded retries:** Maximum 2 auto-recovery attempts before escalation
- **No silent resets:** Recovery only triggers on confirmed corruption pattern
- **Audit trail:** All recovery events logged with timestamps and error details
- **No external exposure:** Recovery uses internal APIs only, no external calls

### Success Metrics

- **Recovery success rate:** >90% of corrupted sessions recovered automatically
- **Time to recovery:** <15 seconds from corruption detection to task resume
- **User intervention rate:** <10% of cases require manual reset
- **Task completion rate:** >95% of interrupted tasks complete after recovery
- **False positive rate:** <1% (no recovery triggered on healthy sessions)

---

## Skill 2: discord-attachment-verifier

### Problem Statement
PDF and file attachments in Discord are intermittently dropped without error messages or user notification. Users cannot determine if attachments were processed successfully, leading to silent data loss and incomplete document analysis workflows.

**Reference:** Issue #30741 - "Discord: attachments silently fail to attach"

### Trigger Conditions
- User message contains file attachment (PDF, DOC, TXT, images, etc.)
- Attachment uploaded to Discord channel
- Agent receives message with attachment metadata
- Any document processing task initiated (read, analyze, summarize)

### Inputs
- Discord message object with attachment array
- Attachment metadata (filename, size, URL, content_type)
- Channel configuration (Discord channel ID)
- Agent task context (what operation requested on attachment)

### Step-by-Step Workflow

1. **Intercept Attachment Message**
   - On message receive, check message.attachments array
   - If empty but user referenced file, flag as potential silent failure
   - Log attachment count and metadata

2. **Pre-Processing Verification**
   - For each attachment, attempt HEAD request to Discord CDN URL
   - Verify HTTP 200 response and content-length matches metadata
   - Check file size > 0 bytes
   - Validate content-type matches expected format

3. **Download and Hash**
   - Download attachment to temporary workspace path
   - Calculate SHA256 hash of downloaded file
   - Verify file is not corrupted (hash matches, file opens)
   - For PDFs: attempt first-page render to confirm validity

4. **Processing Confirmation**
   - After agent processes attachment (read, analyze, etc.), verify:
     - Output references attachment content
     - No error messages about file access
     - Expected data extracted (text, tables, images)

5. **User Feedback Loop**
   - If verification passes: silent success (no notification needed)
   - If verification fails at any step:
     - Notify user immediately: "Attachment [filename] failed verification: [specific error]"
     - Provide retry option or alternative upload method
     - Log failure details for pattern analysis

6. **Post-Processing Cleanup**
   - Delete temporary downloaded files after processing
   - Log successful attachment count and types
   - Update memory with attachment processing stats

### Verification Checklist (Objective Pass/Fail)

- [ ] **PASS:** All attachments in message detected and counted
- [ ] **PASS:** HTTP HEAD request returns 200 for each attachment URL
- [ ] **PASS:** Content-length matches metadata within 5% tolerance
- [ ] **PASS:** File downloads successfully (100% of bytes received)
- [ ] **PASS:** SHA256 hash calculated and file opens without error
- [ ] **PASS:** For PDFs: first page renders successfully
- [ ] **PASS:** Agent output references attachment content
- [ ] **FAIL:** Any verification step fails -> user notified with specific error

### Fallback Path

**If attachment verification fails:**
1. **CDN URL inaccessible:**
   - Notify user: "Discord CDN link expired or inaccessible"
   - Request re-upload or alternative sharing method (Google Drive, direct upload)

2. **File corrupted or zero-byte:**
   - Notify user: "File appears corrupted (0 bytes or invalid format)"
   - Request original file re-upload

3. **Content extraction fails:**
   - Notify user: "File downloaded but content unreadable ([format] error)"
   - Suggest alternative format (e.g., PDF -> TXT, image -> OCR)

4. **Repeated failures (>3 in session):**
   - Flag as systemic Discord attachment issue
   - Switch to alternative workflow: user uploads to workspace directly
   - Create GitHub issue with failure logs

### Privacy/Safety Guardrails

- **Temporary storage only:** Attachments deleted immediately after processing
- **No persistent copies:** Files never saved to long-term storage without explicit user request
- **Hash verification:** Ensures file integrity without content inspection
- **User consent:** Processing only occurs on explicitly shared attachments
- **Access logging:** All attachment downloads logged with timestamp and user ID
- **No external forwarding:** Attachments never sent to third-party services

### Success Metrics

- **Detection rate:** 100% of attachments in messages detected
- **Verification accuracy:** >99% of valid attachments pass verification
- **False positive rate:** <1% (valid attachments incorrectly flagged as failed)
- **User notification latency:** <2 seconds from failure detection to user alert
- **Silent failure elimination:** 0 unreported attachment processing failures
- **Recovery success:** >80% of failed attachments successfully re-processed after user retry

---

## Skill 3: telegram-channel-health-monitor

### Problem Statement
After receiving an image, Telegram channels stop sending outbound messages while inbound messages still work. The channel becomes one-way, breaking bidirectional workflows. Gateway restart temporarily fixes but issue recurs on next image reception.

**Reference:** Issue #30674 - "Telegram channel stops sending messages after receiving an image"

### Trigger Conditions
- Telegram channel receives inbound message with image/photo attachment
- Outbound message send attempt fails or times out
- Channel inbound still functional (messages received but not sent)
- Gateway health check shows normal operation

### Inputs
- Telegram channel ID
- Last inbound message metadata (type: image/photo)
- Outbound send attempt result (error/timeout)
- Gateway health status
- Channel configuration (linked/unlinked status)

### Step-by-Step Workflow

1. **Monitor Inbound Message Types**
   - Track all inbound messages to Telegram channels
   - Flag messages with photo, image, or sticker content type
   - Log timestamp and message ID for image receptions

2. **Detect Send Failure Pattern**
   - On outbound send attempt, monitor response
   - If send fails with timeout or "channel unavailable" error:
     - Check if last inbound message was image (within last 5 minutes)
     - Verify inbound messages still arriving (channel not fully dead)
     - Confirm gateway is healthy (other channels working)

3. **Auto-Diagnosis**
   - Run channel health check:
     - Test inbound: send test message to channel, verify receipt
     - Test outbound: attempt send to channel, capture error
     - Check channel link status in gateway config
   - If inbound works but outbound fails after image: confirm pattern match

4. **Recovery Sequence**
   - **Step 1:** Soft reset channel (re-initialize Telegram bot connection)
     - Send internal command to refresh channel session
     - Wait 5 seconds for reconnection
     - Test outbound send
   
   - **Step 2:** If soft reset fails, hard reset (channel unlink/relink)
     - Unlink channel from gateway
     - Wait 3 seconds
     - Relink channel with same configuration
     - Verify link status = "linked"
     - Test outbound send

   - **Step 3:** If still failing, gateway restart (last resort)
     - Notify user: "Channel recovery requires gateway restart"
     - Trigger gateway restart with 10-second delay
     - Wait for gateway to come online
     - Verify channel status post-restart

5. **User Notification**
   - On detection: "Detected Telegram channel send failure after image reception. Attempting recovery..."
   - On success: "Channel recovered. Outbound messaging restored."
   - On failure: "Channel recovery failed. Manual intervention required: [specific steps]"

6. **Preventive Monitoring**
   - After recovery, monitor next 5 image receptions
   - If issue recurs >2 times in 1 hour:
     - Flag as persistent bug
     - Notify user with GitHub issue recommendation
     - Suggest workaround: disable image reception or use alternative channel

### Verification Checklist (Objective Pass/Fail)

- [ ] **PASS:** Image reception detected and logged
- [ ] **PASS:** Send failure detected within 3 seconds of attempt
- [ ] **PASS:** Pattern confirmed (inbound works, outbound fails, image preceded)
- [ ] **PASS:** Soft reset attempted and tested
- [ ] **PASS:** If soft reset fails, hard reset attempted and tested
- [ ] **PASS:** Outbound send succeeds after recovery
- [ ] **PASS:** User notified at each stage (detection, success/failure)
- [ ] **FAIL:** If all recovery steps fail, escalate with exact error details

### Fallback Path

**If channel recovery fails:**
1. **Immediate workaround:**
   - Notify user: "Channel temporarily unavailable for outbound messages"
   - Suggest alternative: use different channel (Discord, WhatsApp) or web interface
   - Offer to forward messages via alternative channel

2. **Persistent issue (>3 recurrences in 24 hours):**
   - Disable automatic image reception (if configuration allows)
   - Create GitHub issue with detailed logs (timestamps, message IDs, error codes)
   - Recommend channel migration or wait for upstream fix

3. **Gateway-level failure:**
   - If gateway restart doesn't resolve, check Telegram Bot API status
   - Verify bot token validity and permissions
   - Suggest bot re-creation if token compromised

### Privacy/Safety Guardrails

- **No message content inspection:** Only metadata (type: image/photo) examined
- **Bounded recovery attempts:** Maximum 3 auto-recovery steps before escalation
- **User control:** User can disable auto-recovery in channel configuration
- **Audit logging:** All recovery actions logged with timestamps and results
- **No data loss:** Inbound messages preserved during recovery
- **Minimal downtime:** Recovery attempts complete within 30 seconds

### Success Metrics

- **Detection accuracy:** >95% of image-triggered send failures detected
- **Recovery success rate:** >85% of failures resolved without gateway restart
- **Time to recovery:** <30 seconds from detection to outbound restored
- **Gateway restart rate:** <15% of cases require full gateway restart
- **User notification latency:** <2 seconds from detection to user alert
- **False positive rate:** <5% (no recovery triggered on unrelated failures)

---

*Generated: 2026-03-01T15:35:00Z*
